---
id: websocket
title: WebSocket
sidebar_label: WebSocket
---

## IntroduÃ§Ã£o

Com WebSocket Ã© possÃ­vel estabelecer uma conexÃ£o permanente entre o servidor e o navegador do cliente.

Isto quer dizer que a qualquer momento o navegador poderÃ¡ utilizar a conexÃ£o estabelecida via WebSocket para enviar
dados para o servidor, sem ser obrigatÃ³rio obter uma resposta. O mesmo acontece para o servidor que poderÃ¡ contactar
o navegador do cliente enviando dados de forma imediata.

> A comunicaÃ§Ã£o Ã© realizada instantaneamente e a qualquer momento Ã© possÃ­vel transitar dados de um lado para o outro
de forma independente e imediata.

Ã‰ muito Ãºtil para realizar operaÃ§Ãµes de realtime com comunicaÃ§Ãµes imediatas, Ã© como se fosse um chat, um bate-papo
entre o navegador e o servidor, a qualquer momento qualquer um pode enviar uma mensagem e o outro recebe.

Por exemplo, Ã© muito utilizado desde soluÃ§Ãµes de chats no geral atÃ© jogos, utilizamos tambÃ©m para apresentar alteraÃ§Ã£o
de dados ao vivo, ou seja, quando existe a necessidade de realizar comunicaÃ§Ã£o o mais imediata possÃ­vel.

De forma simplificada a diferenÃ§a entre a comunicaÃ§Ã£o clÃ¡ssica HTTP e o WebSocket:

![classic-http-vs-websoket](/docs/assets/academy/server/services/websocket/comparison-pt.svg)

Do lado do servidor Ã© criado um `endpoint`, endereÃ§o que permite estabelecer conexÃµes com WebSocket.

O servidor tem a capacidade de enviar dados apenas para uma conexÃ£o especÃ­fica, ou seja, Ã© possÃ­vel enviar novas
mensagens para um participante de um chat em especÃ­fico.

TambÃ©m o servidor pode fazer `broadcast` que Ã© o envio de dados para todas as conexÃµes ativas num determinado
endereÃ§o, ou seja, quando Ã© enviado uma mensagem para todos os participantes do chat que estÃ£o em uma sala ou em um
grupo.

## AtivaÃ§Ã£o e ConfiguraÃ§Ã£o

Para ativar e configurar o WebSocket na sua aplicaÃ§Ã£o Netuno Ã© necessÃ¡rio editar o arquivo de configuraÃ§Ã£o da
aplicaÃ§Ã£o referente ao ambiente que estÃ¡ sendo utilizado, como:

- `ğŸ“‚ config/_development.json`
- `ğŸ“‚ config/_production.json`

Insira e ajuste os seguintes parÃ¢metros:

```json
    ...
    "ws": {
        "endpoints": [
            {
                "name": "pool",
                "enabled": true,
                "sendTimeout": 10000,
                "idleTimeout": 0,
                "maxText": 15000,
                "public": "/ws/pool",
                "path": "/",
                "service": "/services/ws/pool"
            },
            {
                "name": "room",
                "enabled": true,
                "sendTimeout": 10000,
                "idleTimeout": 0,
                "maxText": 15000,
                "public": "/ws/room",
                "path": "/{uid}",
                "service": "/services/ws/room"
            }
        ]
    },
    ...
```

##### endpoints

Ã‰ um array que permite definir que o servidor vai suportar WebSocket atravÃ©s dos mÃºltiplos endereÃ§os pÃºblicos
especÃ­ficados (_endpoints_), entÃ£o cada endpoint Ã© um endereÃ§o pÃºblico que suporta receber conexÃµes via
WebSockets a partir dos navegadores.

##### name

Nome de identificaÃ§Ã£o do endpoint.

##### enabled

Permite ativar e desativar o endpoint, o padrÃ£o Ã© `true` (ativo).

##### sendTimeout

Limite de tempo mÃ¡ximo para enviar uma mensagem para os clientes, o padrÃ£o Ã© `60000` milissegundos, ou seja, equivale
a 1 minuto.

##### idleTimeout

Limite de tempo mÃ¡ximo para a inatividade na conexÃ£o, o padrÃ£o Ã© `300000` milissegundos, ou seja, equivale a 5 minutos.

##### maxText

Limite em bytes para o tamanho mÃ¡ximo do comprimento da mensagem, o padrÃ£o Ã© `1048576` equivalente a 1 megabyte.

##### public

Define a base do endereÃ§o pÃºblico que permitirÃ¡ receber as conexÃµes via WebSocket vinda dos navegadores.

O endereÃ§o final Ã© constituÃ­do pelo valor da configuraÃ§Ã£o `public` seguido pelo que estÃ¡ definido no `path`.

##### path

Define a parte final do caminho do endereÃ§o pÃºblico, pode ser dinÃ¢mico, o que permite criar por exemplos mÃºltiplos
canais separados, por exemplo Ã© Ãºtil para criar mÃºltiplas salas.

> AtenÃ§Ã£o: O `path` deve sempre iniciar com `/`, e na configuraÃ§Ã£o de conexÃ£o no front-end Ã© muito importante conter
a barra exatamente como definido no `path`.

No front-end o endereÃ§o final serÃ¡ o `public` + `path`, veja o exemplo:

```json
    ...
    "public": "/ws/pool",
    "path": "/",
    ...
```

EntÃ£o o endereÃ§o final no front-end serÃ¡ `/ws/pool/`, com a barra no fim.

##### service

EndereÃ§o da base de serviÃ§o de back-end da aplicaÃ§Ã£o que processa as conexÃµes e a comunicaÃ§Ã£o via WebSocket.

## ServiÃ§o para os Endpoints

### PUT

Ã‰ executado o serviÃ§o configurado com o mÃ©todo `POST` quando uma nova conexÃ£o Ã© estabelecida, por exemplo:

- `server/services/ws/room/post.js`

```js
const uidRoom = _ws.path().getString("uid")
const dbRoom = _db.get('room', uidRoom)

if (dbRoom == null) {
    _log.warn(`Invalid room ${uidRoom}.`)
    _ws.close()
} else {
    _log.info(`New WebSocket Session: ${_ws.sessionId()}`)
}
```

> Normalmente o `_ws.sessionId()` Ã© guardado em base de dados para ser utilizado em futuras comunicaÃ§Ãµes.

### PUT

Se a mensagem recebida nÃ£o for em formato JSON, ou se for um JSON que nÃ£o estÃ¡ no formato suportado para execuÃ§Ã£o de
um serviÃ§o especÃ­fico (`service`), entÃ£o serÃ¡ executado este serviÃ§o genÃ©rico:

- `server/services/ws/room/put.js`

```js
_log.info(`The session ${_ws.sessionId()} sent this message: ${_ws.message()}`)
```

### DELETE

Ã‰ executado quando acontece uma desconexÃ£o do navegador do cliente.

- `server/services/ws/room/delete.js`

```js
_log.info(`Session ${_ws.sessionId()} has disconnected.`)
```

## ComunicaÃ§Ã£o

### sendService

Executa o serviÃ§o e envia o output gerado para um cliente especÃ­fico conectado atravÃ©s do WebSocket, utiliza o ID de
conexÃ£o do cliente (`sessionId`).

##### Exemplo

Este cÃ³digo pode ficar no mÃ©todo POST do serviÃ§o de endpoint (`service`), estÃ¡ a ser utilizado o `_ws.sessionId()` que
obtÃ©m o ID da sessÃ£o de conexÃ£o do cliente, se o identificador de sessÃ£o estivesse guardado em base de dados o
`sendService` poderia ser executado em qualquer outro serviÃ§o a qualquer momento.

```js
const uid = _ws.path().getString("uid")
_ws.sendService(
        _ws.sessionId(), // IdentificaÃ§Ã£o da conexÃ£o atual do WebSocket.
        _val.map() // ParametrizaÃ§Ã£o do serviÃ§o que serÃ¡ executado.
            .set("method", "POST")
            .set("service", "/services/room/participant/new")
            .set(
                "data", // ParÃ¢metros que serÃ£o passados para o serviÃ§o e recebidos atravÃ©s do _req.
                _val.map()
                    .set("uid", uid)
            )
    )
```

Ou seja, na configuraÃ§Ã£o o `path` que estÃ¡ configurado no `endpoint` tem o valor `/{uid}`, assim permite o cliente
conectar atravÃ©s do endereÃ§o pÃºblico:

- `/ws/room/d641f095-30eb-4025-a39c-b2e3e497eab7`

EntÃ£o o valor do `uid` serÃ¡ `d641f095-30eb-4025-a39c-b2e3e497eab7`.

ApÃ³s serÃ¡ executado o serviÃ§o que fica na URL `/services/room/participant/new` e o valor do `uid` Ã© passado.

O `uid` pode ser obtido no cÃ³digo do serviÃ§o que Ã© executado, como um parÃ¢metro do pedido HTTP, por exemplo:

```js
// No cÃ³digo do ServiÃ§o da App: /server/services/room/participant/new.js
const uid = _req.getString('uid')
```

### broadcastService

Para realizar o broadcast Ã© preciso o nome do endpoint do WebSocket, definir o caminho (`path`) se aplicÃ¡vel, e o
serviÃ§o que serÃ¡ executado.

> O output do serviÃ§o serÃ¡ enviado para todas as conexÃµes ativas no `endpoint` especificado.

##### Exemplo

```js
_ws.broadcastService(
        "admin", // Nome do endpoint do WebSocket.
        "/", // Caminho configurado no endpoint (path).
        _val.map() // ParametrizaÃ§Ã£o do serviÃ§o que serÃ¡ executado.
            .set("service", "/services/room/participants")
    )
```

Como no exemplo 

## WS Client - NPM

Para realizar facilmente a integraÃ§Ã£o com o frontend, Ã© disponibilizado o mÃ³dulo do NPM:

- https://www.npmjs.com/package/@netuno/ws-client

Comando de instalaÃ§Ã£o: `npm i -S @netuno/ws-client`

```js
_ws.config({
    url: 'ws://localhost:9000/ws/example',
    servicesPrefix: '/services',
    method: 'GET',
    autoReconnect: true,
    connect: (event) => {
        console.info('WebSocket Connected', event);
    },
    close: (event) => {
        console.warn('WebSocket Closed', event);
    },
    error: (error) => {
        console.error('WebSocket Error', error);
    },
    message: (data, event) => {
        console.debug('WebSocket Message', data);
    }
});
```

## NGINX Proxy Reverso

No NGINX o proxy reverso pode ser configurado desta forma:

```
    location /ws {
        proxy_pass http://localhost:9000;
        proxy_set_header Host minha-app.local.netu.no;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_http_version 1.1;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        add_header X-Frame-Options "";
    }
```

> Na linha 3 onde define o `Host` deve ser ajustado a parte da `minha-app` para o nome da aplicaÃ§Ã£o no Netuno que
suporta WebSocket.

