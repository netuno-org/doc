---
id: websocket
title: WebSocket
sidebar_label: WebSocket
---

import PolyglotCode from "@site/src/components/PolyglotCode";

Mensagens instant√¢neas entre o servidor e o cliente.

## Introdu√ß√£o

Com WebSocket √© poss√≠vel estabelecer uma conex√£o permanente entre o servidor e o navegador do cliente.

Isto quer dizer que a qualquer momento o navegador poder√° utilizar a conex√£o estabelecida via WebSocket para enviar
dados para o servidor, sem ser obrigat√≥rio obter uma resposta. O mesmo acontece para o servidor que poder√° contactar
o navegador do cliente enviando dados de forma imediata.

> A comunica√ß√£o √© realizada instantaneamente e a qualquer momento √© poss√≠vel transitar dados de um lado para o outro
de forma independente e imediata.

√â muito √∫til para realizar opera√ß√µes de realtime com comunica√ß√µes imediatas, √© como se fosse um chat, um bate-papo
entre o navegador e o servidor, a qualquer momento qualquer um pode enviar uma mensagem e o outro recebe.

Por exemplo, √© muito utilizado desde solu√ß√µes de chats no geral at√© jogos, utilizamos tamb√©m para apresentar altera√ß√£o
de dados ao vivo, ou seja, quando existe a necessidade de realizar comunica√ß√£o o mais imediata poss√≠vel.

De forma simplificada a diferen√ßa entre a comunica√ß√£o cl√°ssica HTTP e o WebSocket:

![classic-http-vs-websoket](/docs/assets/academy/server/services/websocket/comparison-pt.svg)

Do lado do servidor √© criado um `endpoint`, endere√ßo que permite estabelecer conex√µes com WebSocket.

O servidor tem a capacidade de enviar dados apenas para uma conex√£o espec√≠fica, ou seja, √© poss√≠vel enviar novas
mensagens para um participante de um chat em espec√≠fico.

Tamb√©m o servidor pode fazer `broadcast` que √© o envio de dados para todas as conex√µes ativas num determinado
endere√ßo, ou seja, quando √© enviado uma mensagem para todos os participantes do chat que est√£o em uma sala ou em um
grupo.

## Ativa√ß√£o e Configura√ß√£o

Para ativar e configurar o WebSocket na sua aplica√ß√£o Netuno √© necess√°rio editar o arquivo de configura√ß√£o da
aplica√ß√£o referente ao ambiente que est√° sendo utilizado, como:

- `üìÇ config/_development.json`
- `üìÇ config/_production.json`

Insira e ajuste os seguintes par√¢metros:

```json
    ...
    "ws": {
        "endpoints": [
            {
                "name": "pool",
                "enabled": true,
                "sendTimeout": 10000,
                "idleTimeout": 0,
                "maxText": 15000,
                "public": "/ws/pool",
                "path": "/",
                "service": "/services/ws/pool"
            },
            {
                "name": "room",
                "enabled": true,
                "sendTimeout": 10000,
                "idleTimeout": 0,
                "maxText": 15000,
                "public": "/ws/room",
                "path": "/{uid}",
                "service": "/services/ws/room"
            }
        ]
    },
    ...
```

#### endpoints

√â um array que permite definir que o servidor vai suportar WebSocket atrav√©s dos m√∫ltiplos endere√ßos p√∫blicos
espec√≠ficados (_endpoints_), ent√£o cada endpoint √© um endere√ßo p√∫blico que suporta receber conex√µes via
WebSockets a partir dos navegadores.

#### name

Nome de identifica√ß√£o do endpoint.

#### enabled

Permite ativar e desativar o endpoint, o padr√£o √© `true` (ativo).

#### sendTimeout

Limite de tempo m√°ximo para enviar uma mensagem para os clientes, o padr√£o √© `60000` milissegundos, ou seja, equivale
a 1 minuto.

#### idleTimeout

Limite de tempo m√°ximo para a inatividade na conex√£o, o padr√£o √© `300000` milissegundos, ou seja, equivale a 5 minutos.

#### maxText

Limite em bytes para o tamanho m√°ximo do comprimento da mensagem, o padr√£o √© `1048576` equivalente a 1 megabyte.

#### public

Define a base do endere√ßo p√∫blico que permitir√° receber as conex√µes via WebSocket vinda dos navegadores.

O endere√ßo final √© constitu√≠do pelo valor da configura√ß√£o `public` seguido pelo que est√° definido no `path`.

#### path

Define a parte final do caminho do endere√ßo p√∫blico, pode ser din√¢mico, o que permite criar por exemplos m√∫ltiplos
canais separados, por exemplo √© √∫til para criar m√∫ltiplas salas.

> Aten√ß√£o: O `path` deve sempre iniciar com `/`, e na configura√ß√£o de conex√£o no front-end √© muito importante conter
a barra exatamente como definido no `path`.

No front-end o endere√ßo final ser√° o `public` + `path`, veja o exemplo:

```json
    ...
    "public": "/ws/pool",
    "path": "/",
    ...
```

Ent√£o o endere√ßo final no front-end ser√° `/ws/pool/`, com a barra no fim.

##### service

Endere√ßo da base de servi√ßo de back-end da aplica√ß√£o que processa as conex√µes e a comunica√ß√£o via WebSocket.

## Servi√ßo para os Endpoints

### POST = nova conex√£o

√â executado o servi√ßo configurado com o m√©todo `POST` quando uma nova conex√£o √© estabelecida, por exemplo:

<PolyglotCode
    file="server/services/ws/room/post"
    codes={[
        {
            lang: 'javascript',
            code: `
                const uidRoom = _ws.path().getString("uid")
                const dbRoom = _db.get("room", uidRoom)

                if (dbRoom == null) {
                    _log.warn(\`Invalid room \${uidRoom}.\`)
                    _ws.close()
                } else {
                    _log.info(\`New WebSocket Session: \${_ws.sessionId()}\`)
                }
            `
        },
        {
            lang: 'python',
            code: `
                uidRoom = _ws.path().getString("uid")
                dbRoom = _db.get("room", uidRoom)

                if dbRoom == null:
                    _log.warn("Invalid room "+ uidRoom +".")
                    _ws.close()
                else:
                    _log.info("New WebSocket Session: "+ _ws.sessionId())
            `
        },
        {
            lang: 'ruby',
            code: `
                uidRoom = _ws.path().getString("uid")
                dbRoom = _db.get("room", uidRoom)

                if dbRoom == null
                    _log.warn("Invalid room #{uidRoom}.")
                    _ws.close()
                else
                    _log.info("New WebSocket Session: #{_ws.sessionId()}")
                end
`
        },
        {
            lang: 'kotlin',
            code: `
                val uidRoom = _ws.path().getString("uid")
                val dbRoom = _db.get("room", uidRoom)

                if (dbRoom == null) {
                    _log.warn("Invalid room \${uidRoom}.")
                    _ws.close()
                } else {
                    _log.info("New WebSocket Session: \${_ws.sessionId()}")
                }
            `
        },
        {
            lang: 'groovy',
            code: `
                def uidRoom = _ws.path().getString("uid")
                def dbRoom = _db.get("room", uidRoom)

                if (dbRoom == null) {
                    _log.warn("Invalid room "+ uidRoom +".")
                    _ws.close()
                } else {
                    _log.info("New WebSocket Session: "+ _ws.sessionId())
                }
            `
        },
    ]}
/>

> Normalmente o `_ws.sessionId()` √© guardado em base de dados para ser utilizado em futuras comunica√ß√µes.

### PUT = nova mensagem

Se a mensagem recebida n√£o for em formato JSON, ou se for um JSON que n√£o est√° no formato suportado para execu√ß√£o de
um servi√ßo espec√≠fico (`service`), ent√£o ser√° executado este servi√ßo gen√©rico:

<PolyglotCode
    file="server/services/ws/room/put"
    codes={[
        {
            lang: 'javascript',
            code: `
                _log.info(\`The session \${_ws.sessionId()} sent this message: \${_ws.message()}\`)
            `
        },
        {
            lang: 'python',
            code: `
                _log.info("The session "+ _ws.sessionId() +" sent this message: "+ _ws.message())
            `
        },
        {
            lang: 'ruby',
            code: `
                _log.info("The session #{_ws.sessionId()} sent this message: #{_ws.message()}")
            `
        },
        {
            lang: 'kotlin',
            code: `
                _log.info("The session \${_ws.sessionId()} sent this message: \${_ws.message()}")
            `
        },
        {
            lang: 'groovy',
            code: `
                _log.info("The session "+ _ws.sessionId() +" sent this message: "+ _ws.message())
            `
        },
    ]}
/>

### DELETE = fechou a conex√£o

√â executado quando acontece uma desconex√£o do navegador do cliente.

<PolyglotCode
    file="server/services/ws/room/delete"
    codes={[
        {
            lang: 'javascript',
            code: `
                _log.info(\`Session \${_ws.sessionId()} has disconnected.\`)
            `
        },
        {
            lang: 'python',
            code: `
                _log.info("Session "+ _ws.sessionId() +" has disconnected.")
            `
        },
        {
            lang: 'ruby',
            code: `
                _log.info("Session #{_ws.sessionId()} has disconnected.")
            `
        },
        {
            lang: 'kotlin',
            code: `
                _log.info("Session \${_ws.sessionId()} has disconnected.")
            `
        },
        {
            lang: 'groovy',
            code: `
                _log.info("Session "+ _ws.sessionId() +" has disconnected.")
            `
        },
    ]}
/>


### GET = fluxo cont√≠nuo de mensagens

Inicia a execu√ß√£o quando acontece uma nova conex√£o do navegador do cliente, e a execu√ß√£o √© mantida at√© finalizar
a conex√£o.

Ou seja, o servi√ßo para o m√©todo HTTP `GET` fica recebendo as mensagens que est√£o vindo do cliente continuamente
em `stream`, ou seja, √© um fluxo aberto e cont√≠nuo de mensagens que tando pode receber como enviar.

<PolyglotCode
    file="server/services/ws/room/get"
    codes={[
        {
            lang: 'javascript',
            code: `
                if (_ws.isStream()) {
                    while (_ws.awaitStream()) {
                        if (_ws.isBinaryStreamed()) {
                            _log.info("Nova mensagem bin√°ria recebida: "+ _convert.textFromBytes(_ws.binaryStreamed()))
                        } else if (_ws.isTextStreamed()) {
                            _log.info("Nova mensagem de texto recebida: "+ _ws.textStreamed())
                        }
                        _ws.sendText("Ok! A mensagem foi recebida com sucesso.")
                    }
                }
            `
        },
        {
            lang: 'python',
            code: `
                if _ws.isStream():
                    while _ws.awaitStream():
                        if _ws.isBinaryStreamed():
                            _log.info("Nova mensagem bin√°ria recebida: "+ _convert.textFromBytes(_ws.binaryStreamed()))
                        elif _ws.isTextStreamed():
                            _log.info("Nova mensagem de texto recebida: "+ _ws.textStreamed())
                        _ws.sendText("Ok! A mensagem foi recebida com sucesso.")
            `
        },
        {
            lang: 'ruby',
            code: `
                if _ws.isStream()
                    while _ws.awaitStream()
                        if _ws.isBinaryStreamed()
                            _log.info("Nova mensagem bin√°ria recebida: "+ _convert.textFromBytes(_ws.binaryStreamed()))
                        elsif _ws.isTextStreamed()
                            _log.info("Nova mensagem de texto recebida: "+ _ws.textStreamed())
                        end
                        _ws.sendText("Ok! A mensagem foi recebida com sucesso.")
                    end
                end
            `
        },
    ]}
/>


O `if` com o `_ws.isStream()` faz com que verifique se realmente √© um pedido interno gerido pelo WebSocket para
realizar o stream.

No `while` com o `_ws.awaitStream()` fica aguardando que um novo fluxo de mensagem chegue, ou seja, aguarda a
chegada de uma nova mensagem. Assim que houver uma nova mensagem √© executado o c√≥digo interno do `while`.

> O `_ws.awaitStream()` funciona como um loop infinito aguardando uma nova mensagem.

Ent√£o nos `ifs` internos do `while` √© verificado o tipo de mensagem, se a mensagem √© bin√°ria ou de texto, em ambos
os casos √© apresentado nos logs o conte√∫do destas mensagens. Repare que qualquer formato de mensagem pode ser
utilizado, podendo ser processadas de qualquer maneira que seja conveniente.

Finalmente no `_ws.sendText` √© enviada uma mensagem de resposta ao cliente, confirma a recep√ß√£o.

> Cada execu√ß√£o do servi√ßo `GET` ser√° uma conex√£o de ativa.

Quando a conex√£o com o endpoint do WebSocket for finalizada ent√£o a execu√ß√£o deste servi√ßo √© finalizada
internamente.

## Comunica√ß√£o

### sendService

Executa o servi√ßo e envia o output gerado para um cliente espec√≠fico conectado atrav√©s do WebSocket, utiliza o ID de
conex√£o do cliente (`sessionId`).

#### Exemplo da Chamada de Servi√ßo

O c√≥digo abaixo pode ser utilizado no servi√ßo de m√©todo PUT do endpoint (`service`), repare que est√° sendo
utilizado o `_ws.sessionId()` que obt√©m o ID da sess√£o de conex√£o do cliente, se o identificador de sess√£o
estiver guardado em base de dados o `sendService` poderia ser executado em qualquer outro servi√ßo a qualquer
momento.

<PolyglotCode
    codes={[
        {
            lang: 'javascript',
            code: `
                const uid = _ws.path().getString("uid")
                _ws.sendService(
                    _ws.sessionId(), // Identifica√ß√£o da conex√£o atual do WebSocket.
                    _val.map() // Parametriza√ß√£o do servi√ßo que ser√° executado.
                        .set("method", "POST")
                        .set("service", "/services/room/participant/new")
                        .set(
                            "data", // Par√¢metros que ser√£o passados para o servi√ßo e recebidos atrav√©s do _req.
                            _val.map()
                                .set("uid", uid)
                        )
                )
            `
        },
    ]}
/>

Ou seja, na configura√ß√£o o `path` que est√° configurado no `endpoint` tem o valor `/{uid}`, assim permite o cliente
conectar atrav√©s do endere√ßo p√∫blico:

- `/ws/room/d641f095-30eb-4025-a39c-b2e3e497eab7`

Ent√£o o valor do `uid` ser√° `d641f095-30eb-4025-a39c-b2e3e497eab7`.

Ap√≥s ser√° executado o servi√ßo que fica na URL `/services/room/participant/new` e o valor do `uid` √© passado.

O `uid` pode ser obtido no c√≥digo do servi√ßo que √© executado, como um par√¢metro do pedido HTTP, veja um exemplo:

<PolyglotCode
    file="/server/services/room/participant/new"
    codes={[
        {
            lang: 'javascript',
            code: `
                // O UID enviado √© obtido diretamente no request.
                const uid = _req.getString('uid')
            `
        },
    ]}
/>

### broadcastService

Para realizar o broadcast √© preciso o nome do endpoint do WebSocket, definir o caminho (`path`) se aplic√°vel, e o
servi√ßo que ser√° executado.

> O output do servi√ßo ser√° enviado para todas as conex√µes ativas no `endpoint` especificado.

#### Exemplo de Broadcast

<PolyglotCode
    file="/server/services/room/participant/new"
    codes={[
        {
            lang: 'javascript',
            code: `
                _ws.broadcastService(
                    "admin", // Nome do endpoint do WebSocket.
                    "/", // Caminho configurado no endpoint (path).
                    _val.map() // Parametriza√ß√£o do servi√ßo que ser√° executado.
                        .set("service", "/services/room/participants")
                )
            `
        },
    ]}
/>

Neste exemplo o conte√∫do de output gerado pelo servi√ßo `room/participants` ser√° enviado para todos que estiverem
conectados no endpoint `admin`.

## WS Client - NPM

Para realizar facilmente a integra√ß√£o com o frontend, √© disponibilizado o m√≥dulo do NPM:

- https://www.npmjs.com/package/@netuno/ws-client

Comando de instala√ß√£o: `npm i -S @netuno/ws-client`

```js
_ws.config({
    url: 'ws://localhost:9000/ws/example',
    servicesPrefix: '/services',
    method: 'GET',
    autoReconnect: true,
    connect: (event) => {
        console.info('WebSocket Connected', event);
    },
    close: (event) => {
        console.warn('WebSocket Closed', event);
    },
    error: (error) => {
        console.error('WebSocket Error', error);
    },
    message: (data, event) => {
        console.debug('WebSocket Message', data);
    }
});
```

## NGINX Proxy Reverso

No NGINX o proxy reverso pode ser configurado desta forma:

```
    location /ws {
        proxy_pass http://localhost:9000;
        proxy_set_header Host minha-app.local.netu.no;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_http_version 1.1;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        add_header X-Frame-Options "";
    }
```

> Na linha 3 onde define o `Host` deve ser ajustado a parte da `minha-app` para o nome da aplica√ß√£o no Netuno que
suporta WebSocket.

